## API Report File for "@gooddata/sdk-backend-spi"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttributeOrMeasure } from '@gooddata/sdk-model';
import { IAttribute } from '@gooddata/sdk-model';
import { IBucket } from '@gooddata/sdk-model';
import { IColorPaletteItem } from '@gooddata/sdk-model';
import { IDimension } from '@gooddata/sdk-model';
import { IFilter } from '@gooddata/sdk-model';
import { IInsight } from '@gooddata/sdk-model';
import { IMeasure } from '@gooddata/sdk-model';
import { ITotal } from '@gooddata/sdk-model';
import { IVisualizationClass } from '@gooddata/sdk-model';
import { SortItem } from '@gooddata/sdk-model';

// @public
export type AnalyticalBackendConfig = {
    readonly hostname?: string;
    readonly username?: string;
};

// @public
export abstract class AnalyticalBackendError extends Error {
    protected constructor(message: string, abeType: string, cause?: Error | undefined);
    // (undocumented)
    readonly abeType: string;
    // (undocumented)
    readonly cause?: Error | undefined;
}

// @public
export type AnalyticalBackendFactory = (config?: AnalyticalBackendConfig, implConfig?: any) => IAnalyticalBackend;

// @public
export type BackendCapabilities = {
    supportsObjectUris?: boolean;
    canCalculateTotals?: boolean;
    canSortData?: boolean;
    supportsElementUris?: boolean;
    maxDimensions?: number;
    canExportCsv?: boolean;
    canExportXlsx?: boolean;
    canTransformExistingResult?: boolean;
    canExecuteByReference?: boolean;
    [key: string]: undefined | boolean | number | string;
};

// @public
export type DataValue = null | string | number;

// @public
export class DataViewError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export class DataViewFacade {
    constructor(dataView: IDataView);
    // (undocumented)
    attributeHeaders(): IResultAttributeHeaderItem[][][];
    // (undocumented)
    attributes(): IAttribute[];
    // (undocumented)
    bucket(id: string): IBucket | undefined;
    // (undocumented)
    bucketCount(): number;
    // (undocumented)
    bucketMeasures(id: string): IMeasure[];
    // (undocumented)
    buckets(): IBucket[];
    // (undocumented)
    data(): DataValue[][] | DataValue[];
    // (undocumented)
    dataAt(index: number): DataValue | DataValue[];
    // (undocumented)
    readonly dataView: IDataView;
    // (undocumented)
    readonly definition: IExecutionDefinition;
    // (undocumented)
    dimensionHeaders(dimIdx: number): IHeader[];
    // (undocumented)
    dimensions(): IResultDimension[];
    // (undocumented)
    fingerprint(): () => string;
    // (undocumented)
    firstDimSize(): number;
    // (undocumented)
    hasAttributes(): boolean;
    // (undocumented)
    hasBuckets(): boolean;
    // (undocumented)
    hasMeasures(): boolean;
    // (undocumented)
    hasTotals(): boolean;
    // (undocumented)
    headerItems(): IResultHeaderItem[][][];
    // (undocumented)
    isBucketEmpty(id: string): boolean;
    // (undocumented)
    isDerivedMeasure(measureHeader: IMeasureHeaderItem): boolean;
    // (undocumented)
    masterMeasureForDerived(id: string): IMeasure | undefined;
    // (undocumented)
    measure(id: string): IMeasure | undefined;
    // (undocumented)
    measureGroupHeader(): IMeasureGroupHeader | undefined;
    // (undocumented)
    measureGroupHeaderItem(id: string): IMeasureHeaderItem | undefined;
    // (undocumented)
    measureGroupHeaderItems(): IMeasureHeaderItem[];
    // (undocumented)
    measureIndex(id: string): number;
    // (undocumented)
    measures(): IMeasure[];
    // (undocumented)
    result(): IExecutionResult;
    // (undocumented)
    secondDimSize(): number;
    // (undocumented)
    singleDimData(): DataValue[];
    // (undocumented)
    totals(): DataValue[][][] | undefined;
    // (undocumented)
    twoDimData(): DataValue[][];
}

// @public
export function defaultDimensionsGenerator(definition: IExecutionDefinition): IDimension[];

// @public
export function defFingerprint(def: IExecutionDefinition): string;

// Warning: (ae-internal-missing-underscore) The name "defForBuckets" should be prefixed with an underscore because the declaration is marked as @internal
// 
// @internal
export function defForBuckets(workspace: string, buckets: IBucket[], filters?: IFilter[]): IExecutionDefinition;

// Warning: (ae-internal-missing-underscore) The name "defForInsight" should be prefixed with an underscore because the declaration is marked as @internal
// 
// @internal
export function defForInsight(workspace: string, insight: IInsight, filters?: IFilter[]): IExecutionDefinition;

// Warning: (ae-internal-missing-underscore) The name "defForItems" should be prefixed with an underscore because the declaration is marked as @internal
// 
// @internal
export function defForItems(workspace: string, items: AttributeOrMeasure[], filters?: IFilter[]): IExecutionDefinition;

// @public
export function defSetDimensions(def: IExecutionDefinition, dimensions?: IDimension[]): IExecutionDefinition;

// @public
export function defSetSorts(def: IExecutionDefinition, sorts?: SortItem[]): IExecutionDefinition;

// @public
export function defTotals(def: IExecutionDefinition, dimIdx: number): ITotal[];

// Warning: (ae-internal-missing-underscore) The name "defWithDimensions" should be prefixed with an underscore because the declaration is marked as @internal
// 
// @internal
export function defWithDimensions(definition: IExecutionDefinition, dims: Array<IDimension | DimensionGenerator>): IExecutionDefinition;

// @public
export function defWithFilters(def: IExecutionDefinition, filters?: IFilter[]): IExecutionDefinition;

// Warning: (ae-internal-missing-underscore) The name "defWithSorting" should be prefixed with an underscore because the declaration is marked as @internal
// 
// @internal
export function defWithSorting(definition: IExecutionDefinition, sorts: SortItem[]): IExecutionDefinition;

// @public
export type DimensionGenerator = (buckets: IBucket[]) => IDimension[];

// @public
export type Element = {
    readonly value: string;
    readonly uri?: string;
};

// @public
export function emptyDef(workspace: string): IExecutionDefinition;

// @public
export class ExecutionError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export interface IAnalyticalBackend {
    readonly capabilities: BackendCapabilities;
    readonly config: AnalyticalBackendConfig;
    isAuthenticated(): Promise<boolean>;
    onHostname(hostname: string): IAnalyticalBackend;
    withCredentials(username: string, password: string): IAnalyticalBackend;
    withTelemetry(componentName: string, props: object): IAnalyticalBackend;
    workspace(id: string): IAnalyticalWorkspace;
}

// @public
export interface IAnalyticalWorkspace {
    // (undocumented)
    elements(): IElementQueryFactory;
    // (undocumented)
    execution(): IExecutionFactory;
    // (undocumented)
    featureFlags(): IFeatureFlagsQuery;
    // (undocumented)
    metadata(): IWorkspaceMetadata;
    // (undocumented)
    styling(): IWorkspaceStyling;
    // (undocumented)
    readonly workspace: string;
}

// @public
export interface IAttributeHeader {
    // (undocumented)
    attributeHeader: {
        uri: string;
        identifier: string;
        localIdentifier: string;
        name: string;
        totalItems?: ITotalHeaderItem[];
        formOf: {
            uri: string;
            identifier: string;
            name: string;
        };
    };
}

// @public
export interface IDataView {
    advance(...dims: number[]): Promise<IDataView | null>;
    readonly count: number[];
    // (undocumented)
    readonly data: DataValue[][] | DataValue[];
    readonly definition: IExecutionDefinition;
    equals(other: IDataView): boolean;
    fingerprint(): string;
    readonly headerItems: IResultHeaderItem[][][];
    readonly offset: number[];
    pageDown(): Promise<IDataView | null>;
    pageLeft(): Promise<IDataView | null>;
    pageRight(): Promise<IDataView | null>;
    pageUp(): Promise<IDataView | null>;
    readonly result: IExecutionResult;
    readonly totalCount: number[];
    // (undocumented)
    readonly totals?: DataValue[][][];
}

// @public
export interface IElementQuery {
    // (undocumented)
    query(): IElementQueryResult;
    // (undocumented)
    withLimit(limit: number): IElementQuery;
    // (undocumented)
    withOffset(offset: number): IElementQuery;
}

// @public
export interface IElementQueryFactory {
    // (undocumented)
    forObject(objectId: string): IElementQuery;
}

// @public
export interface IElementQueryResult {
    // (undocumented)
    readonly elements: Element[];
    // (undocumented)
    readonly limit: number;
    // (undocumented)
    next(): IElementQueryResult;
    // (undocumented)
    readonly offset: number;
}

// @public
export interface IExecutionDefinition {
    // (undocumented)
    readonly attributes: IAttribute[];
    // (undocumented)
    readonly buckets: IBucket[];
    // (undocumented)
    readonly dimensions: IDimension[];
    // (undocumented)
    readonly filters: IFilter[];
    // (undocumented)
    readonly measures: IMeasure[];
    // (undocumented)
    readonly sortBy: SortItem[];
    // (undocumented)
    readonly workspace: string;
}

// @public
export interface IExecutionFactory {
    forBuckets(buckets: IBucket[], filters?: IFilter[]): IPreparedExecution;
    forDefinition(def: IExecutionDefinition): IPreparedExecution;
    forInsight(insight: IInsight, filters?: IFilter[]): IPreparedExecution;
    forInsightByRef(uri: string, filters?: IFilter[]): Promise<IPreparedExecution>;
    forItems(items: AttributeOrMeasure[], filters?: IFilter[]): IPreparedExecution;
}

// @public
export interface IExecutionResult {
    readonly definition: IExecutionDefinition;
    readonly dimensions: IResultDimension[];
    equals(other: IExecutionResult): boolean;
    export(options: IExportConfig): Promise<IExportResult>;
    fingerprint(): string;
    readAll(): Promise<IDataView>;
    readWindow(offset: number[], size: number[]): Promise<IDataView>;
    transform(): IPreparedExecution;
}

// @public
export interface IExportConfig {
    // (undocumented)
    format?: "xlsx" | "csv" | "raw";
    // (undocumented)
    mergeHeaders?: boolean;
    // (undocumented)
    showFilters?: IFilter[];
    // (undocumented)
    title?: string;
}

// @public
export interface IExportResult {
    // (undocumented)
    uri: string;
}

// @public
export interface IFeatureFlags {
    // (undocumented)
    [key: string]: number | boolean | string;
}

// @public
export interface IFeatureFlagsQuery {
    // (undocumented)
    query(): Promise<IFeatureFlags>;
}

// @public
export type IHeader = IMeasureGroupHeader | IAttributeHeader;

// @public
export interface IMeasureGroupHeader {
    // (undocumented)
    measureGroupHeader: {
        items: IMeasureHeaderItem[];
        totalItems?: ITotalHeaderItem[];
    };
}

// @public
export interface IMeasureHeaderItem {
    // (undocumented)
    measureHeaderItem: {
        uri?: string;
        identifier?: string;
        localIdentifier: string;
        name: string;
        format: string;
    };
}

// @public
export interface IPreparedExecution {
    readonly definition: IExecutionDefinition;
    equals(other: IPreparedExecution): boolean;
    execute(): Promise<IExecutionResult>;
    fingerprint(): string;
    withDimensions(...dim: IDimension[]): IPreparedExecution;
    withDimensions(f: DimensionGenerator): IPreparedExecution;
    withSorting(...items: SortItem[]): IPreparedExecution;
}

// @public
export interface IResultAttributeHeaderItem {
    // (undocumented)
    attributeHeaderItem: {
        uri: string;
        name: string;
    };
}

// @public
export interface IResultDimension {
    // (undocumented)
    headers: IHeader[];
}

// @public
export type IResultHeaderItem = IResultAttributeHeaderItem | IResultMeasureHeaderItem | IResultTotalHeaderItem;

// @public
export interface IResultMeasureHeaderItem {
    // (undocumented)
    measureHeaderItem: {
        name: string;
        order: number;
    };
}

// @public
export interface IResultTotalHeaderItem {
    // (undocumented)
    totalHeaderItem: {
        name: string;
        type: string;
    };
}

// @public
export function isAnalyticalBackendError(obj: any): obj is AnalyticalBackendError;

// @public
export function isAttributeHeader(obj: any): obj is IAttributeHeader;

// @public
export function isDataViewError(obj: any): obj is DataViewError;

// @public
export function isExecutionError(obj: any): obj is ExecutionError;

// @public
export function isMeasureGroupHeader(obj: any): obj is IMeasureGroupHeader;

// @public
export function isMeasureHeaderItem(obj: any): obj is IMeasureHeaderItem;

// @public
export function isNotAuthenticated(obj: any): obj is NotAuthenticated;

// @public
export function isNotImplemented(obj: any): obj is NotImplemented;

// @public
export function isNotSupported(obj: any): obj is NotSupported;

// @public
export function isResultAttributeHeaderItem(obj: any): obj is IResultAttributeHeaderItem;

// @public
export function isResultMeasureHeaderItem(obj: any): obj is IResultMeasureHeaderItem;

// @public
export function isResultTotalHeaderItem(obj: any): obj is IResultTotalHeaderItem;

// @public
export function isTotalHeader(obj: any): obj is ITotalHeaderItem;

// @public
export interface ITotalHeaderItem {
    // (undocumented)
    totalHeaderItem: {
        name: string;
    };
}

// @public
export interface IWorkspaceMetadata {
    // (undocumented)
    getInsight(id: string): Promise<IInsight>;
    // (undocumented)
    getVisualizationClass(id: string): Promise<IVisualizationClass>;
    // (undocumented)
    getVisualizationClasses(): Promise<IVisualizationClass[]>;
}

// @public
export interface IWorkspaceStyling {
    // (undocumented)
    colorPalette(): Promise<IColorPaletteItem[]>;
}

// @public
export function newDefFromBuckets(workspace: string, buckets: IBucket[]): IExecutionDefinition;

// @public
export function newDefFromInsight(workspace: string, insight: IInsight): IExecutionDefinition;

// @public
export function newDefFromItems(workspace: string, items: AttributeOrMeasure[]): IExecutionDefinition;

// @public
export class NotAuthenticated extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export class NotImplemented extends AnalyticalBackendError {
    constructor(message: string);
}

// @public
export class NotSupported extends AnalyticalBackendError {
    constructor(message: string);
}

// @public
export function prepareExecution(backend: IAnalyticalBackend, definition: IExecutionDefinition): IPreparedExecution;


// (No @packageDocumentation comment for this package)

```
