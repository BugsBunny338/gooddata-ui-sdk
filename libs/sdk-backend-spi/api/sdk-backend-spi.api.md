## API Report File for "@gooddata/sdk-backend-spi"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttributeOrMeasure } from '@gooddata/sdk-model';
import { DimensionGenerator } from '@gooddata/sdk-model';
import { IAttribute } from '@gooddata/sdk-model';
import { IAttributeDisplayForm } from '@gooddata/sdk-model';
import { IBucket } from '@gooddata/sdk-model';
import { IColorPalette } from '@gooddata/sdk-model';
import { IDimension } from '@gooddata/sdk-model';
import { IExecutionDefinition } from '@gooddata/sdk-model';
import { IFilter } from '@gooddata/sdk-model';
import { IInsight } from '@gooddata/sdk-model';
import { IMeasure } from '@gooddata/sdk-model';
import { IVisualizationClass } from '@gooddata/sdk-model';
import { SortDirection } from '@gooddata/sdk-model';
import { SortItem } from '@gooddata/sdk-model';

// @public
export type AnalyticalBackendConfig = {
    readonly hostname?: string;
};

// @public
export abstract class AnalyticalBackendError extends Error {
    protected constructor(message: string, abeType: string, cause?: Error | undefined);
    // (undocumented)
    readonly abeType: string;
    // (undocumented)
    readonly cause?: Error | undefined;
}

// @public
export type AnalyticalBackendFactory = (config?: AnalyticalBackendConfig, implConfig?: any) => IAnalyticalBackend;

// @public
export type AuthenticatedPrincipal = {
    userId: string;
    userMeta?: any;
};

// @public
export type AuthenticationContext = {
    client: any;
};

// @public
export type BackendCapabilities = {
    supportsObjectUris?: boolean;
    canCalculateTotals?: boolean;
    canSortData?: boolean;
    supportsElementUris?: boolean;
    maxDimensions?: number;
    canExportCsv?: boolean;
    canExportXlsx?: boolean;
    canTransformExistingResult?: boolean;
    canExecuteByReference?: boolean;
    [key: string]: undefined | boolean | number | string;
};

// @public
export type DataValue = null | string | number;

// @public
export class DataViewError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @alpha
export class DataViewFacade {
    constructor(dataView: IDataView);
    // (undocumented)
    allHeaders(): IResultHeader[][][];
    // (undocumented)
    attributeHeaders(): IResultAttributeHeader[][][];
    // (undocumented)
    attributes(): IAttribute[];
    bucket(localId: string): IBucket | undefined;
    // (undocumented)
    bucketCount(): number;
    bucketMeasures(localId: string): IMeasure[];
    // (undocumented)
    buckets(): IBucket[];
    // (undocumented)
    data(): DataValue[][] | DataValue[];
    // (undocumented)
    dataAt(index: number): DataValue | DataValue[];
    // (undocumented)
    readonly dataView: IDataView;
    // (undocumented)
    readonly definition: IExecutionDefinition;
    // (undocumented)
    dimensionItemDescriptors(dimIdx: number): IDimensionItemDescriptor[];
    // (undocumented)
    dimensions(): IDimensionDescriptor[];
    // (undocumented)
    fingerprint(): () => string;
    // (undocumented)
    firstDimSize(): number;
    // (undocumented)
    hasAttributes(): boolean;
    hasBuckets(): boolean;
    hasTotals(): boolean;
    isBucketEmpty(localId: string): boolean;
    isDerivedMeasure(measureDescriptor: IMeasureDescriptor): boolean;
    masterMeasureForDerived(localId: string): IMeasure | undefined;
    measure(localId: string): IMeasure | undefined;
    measureDescriptor(localId: string): IMeasureDescriptor | undefined;
    measureDescriptors(): IMeasureDescriptor[];
    // (undocumented)
    measureGroupDescriptor(): IMeasureGroupDescriptor | undefined;
    measureIndex(localId: string): number;
    // (undocumented)
    measures(): IMeasure[];
    // (undocumented)
    result(): IExecutionResult;
    singleDimData(): DataValue[];
    // (undocumented)
    totals(): DataValue[][][] | undefined;
    twoDimData(): DataValue[][];
}

// @public
export class ExecutionError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export interface IAnalyticalBackend {
    authenticate(force?: boolean): Promise<AuthenticatedPrincipal>;
    readonly capabilities: BackendCapabilities;
    readonly config: AnalyticalBackendConfig;
    isAuthenticated(): Promise<AuthenticatedPrincipal | null>;
    onHostname(hostname: string): IAnalyticalBackend;
    withAuthentication(provider: IAuthenticationProvider): IAnalyticalBackend;
    withTelemetry(componentName: string, props: object): IAnalyticalBackend;
    workspace(id: string): IAnalyticalWorkspace;
}

// @public
export interface IAnalyticalWorkspace {
    elements(): IElementQueryFactory;
    execution(): IExecutionFactory;
    metadata(): IWorkspaceMetadata;
    settings(): IWorkspaceSettingsService;
    styling(): IWorkspaceStylingService;
    // (undocumented)
    readonly workspace: string;
}

// @public
export interface IAttributeDescriptor {
    // (undocumented)
    attributeHeader: {
        uri: string;
        identifier: string;
        localIdentifier: string;
        name: string;
        totalItems?: ITotalDescriptor[];
        formOf: {
            uri: string;
            identifier: string;
            name: string;
        };
    };
}

// @public
export interface IAuthenticationProvider {
    authenticate(context: AuthenticationContext): Promise<AuthenticatedPrincipal>;
}

// @public
export interface IDataView {
    readonly count: number[];
    readonly data: DataValue[][] | DataValue[];
    readonly definition: IExecutionDefinition;
    equals(other: IDataView): boolean;
    fingerprint(): string;
    readonly headerItems: IResultHeader[][][];
    readonly offset: number[];
    readonly result: IExecutionResult;
    readonly totalCount: number[];
    readonly totals?: DataValue[][][];
}

// @public
export interface IDimensionDescriptor {
    // (undocumented)
    headers: IDimensionItemDescriptor[];
}

// @public
export type IDimensionItemDescriptor = IMeasureGroupDescriptor | IAttributeDescriptor;

// @public
export interface IElement {
    // (undocumented)
    readonly title: string;
    // (undocumented)
    readonly uri?: string;
}

// @public
export interface IElementQuery {
    // (undocumented)
    query(): Promise<IElementQueryResult>;
    // (undocumented)
    withLimit(limit: number): IElementQuery;
    // (undocumented)
    withOffset(offset: number): IElementQuery;
    // (undocumented)
    withOptions(options: IElementQueryOptions): IElementQuery;
}

// @public
export interface IElementQueryFactory {
    // (undocumented)
    forObject(objectId: string): IElementQuery;
}

// @public
export interface IElementQueryOptions {
    // (undocumented)
    complement?: boolean;
    // (undocumented)
    filter?: string;
    // (undocumented)
    includeTotalCountWithoutFilters?: boolean;
    // (undocumented)
    order?: SortDirection;
    // (undocumented)
    prompt?: string;
    // (undocumented)
    restrictiveDefinition?: string;
    // (undocumented)
    restrictiveDefinitionContent?: object;
    // (undocumented)
    uris?: string[];
}

// @public
export interface IElementQueryResult {
    // (undocumented)
    readonly elements: IElement[];
    // (undocumented)
    readonly limit: number;
    // (undocumented)
    next(): Promise<IElementQueryResult>;
    // (undocumented)
    readonly offset: number;
    // (undocumented)
    readonly totalCount: number;
}

// @public
export interface IExecutionFactory {
    forBuckets(buckets: IBucket[], filters?: IFilter[]): IPreparedExecution;
    forDefinition(def: IExecutionDefinition): IPreparedExecution;
    forInsight(insight: IInsight, filters?: IFilter[]): IPreparedExecution;
    forInsightByRef(uri: string, filters?: IFilter[]): Promise<IPreparedExecution>;
    forItems(items: AttributeOrMeasure[], filters?: IFilter[]): IPreparedExecution;
}

// @public
export interface IExecutionResult {
    readonly definition: IExecutionDefinition;
    readonly dimensions: IDimensionDescriptor[];
    equals(other: IExecutionResult): boolean;
    export(options: IExportConfig): Promise<IExportResult>;
    fingerprint(): string;
    readAll(): Promise<IDataView>;
    readWindow(offset: number[], size: number[]): Promise<IDataView>;
    transform(): IPreparedExecution;
}

// @public
export interface IExportConfig {
    format?: "xlsx" | "csv" | "raw";
    mergeHeaders?: boolean;
    showFilters?: IFilter[];
    title?: string;
}

// @public
export interface IExportResult {
    // (undocumented)
    uri: string;
}

// @public
export interface IMeasureDescriptor {
    // (undocumented)
    measureHeaderItem: {
        uri?: string;
        identifier?: string;
        localIdentifier: string;
        name: string;
        format: string;
    };
}

// @public
export interface IMeasureGroupDescriptor {
    // (undocumented)
    measureGroupHeader: {
        items: IMeasureDescriptor[];
        totalItems?: ITotalDescriptor[];
    };
}

// @public
export interface IPreparedExecution {
    readonly definition: IExecutionDefinition;
    equals(other: IPreparedExecution): boolean;
    execute(): Promise<IExecutionResult>;
    fingerprint(): string;
    withDimensions(...dim: Array<IDimension | DimensionGenerator>): IPreparedExecution;
    withSorting(...items: SortItem[]): IPreparedExecution;
}

// @public
export interface IResultAttributeHeader {
    // (undocumented)
    attributeHeaderItem: {
        uri: string;
        name: string;
    };
}

// @public
export type IResultHeader = IResultAttributeHeader | IResultMeasureHeader | IResultTotalHeader;

// @public
export interface IResultMeasureHeader {
    // (undocumented)
    measureHeaderItem: {
        name: string;
        order: number;
    };
}

// @public
export interface IResultTotalHeader {
    // (undocumented)
    totalHeaderItem: {
        name: string;
        type: string;
    };
}

// @public
export function isAnalyticalBackendError(obj: any): obj is AnalyticalBackendError;

// @public
export function isAttributeDescriptor(obj: any): obj is IAttributeDescriptor;

// @public
export function isDataViewError(obj: any): obj is DataViewError;

// @public
export function isExecutionError(obj: any): obj is ExecutionError;

// @public
export function isMeasureDescriptor(obj: any): obj is IMeasureDescriptor;

// @public
export function isMeasureGroupDescriptor(obj: any): obj is IMeasureGroupDescriptor;

// @public
export function isNotAuthenticated(obj: any): obj is NotAuthenticated;

// @public
export function isNotImplemented(obj: any): obj is NotImplemented;

// @public
export function isNotSupported(obj: any): obj is NotSupported;

// @public
export function isResultAttributeHeader(obj: any): obj is IResultAttributeHeader;

// @public
export function isResultMeasureHeader(obj: any): obj is IResultMeasureHeader;

// @public
export function isResultTotalHeader(obj: any): obj is IResultTotalHeader;

// @public
export function isTotalDescriptor(obj: any): obj is ITotalDescriptor;

// @public
export interface ITotalDescriptor {
    // (undocumented)
    totalHeaderItem: {
        name: string;
    };
}

// @public
export interface IWorkspaceMetadata {
    getAttributeDisplayForm(id: string): Promise<IAttributeDisplayForm>;
    // (undocumented)
    getInsight(id: string): Promise<IInsight>;
    // (undocumented)
    getVisualizationClass(id: string): Promise<IVisualizationClass>;
    // (undocumented)
    getVisualizationClasses(): Promise<IVisualizationClass[]>;
}

// @public
export interface IWorkspaceSettings {
    [key: string]: number | boolean | string;
    workspace: string;
}

// @public
export interface IWorkspaceSettingsService {
    query(): Promise<IWorkspaceSettings>;
}

// @public
export interface IWorkspaceStylingService {
    colorPalette(): Promise<IColorPalette>;
}

// @public
export class NotAuthenticated extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export class NotImplemented extends AnalyticalBackendError {
    constructor(message: string);
}

// @public
export class NotSupported extends AnalyticalBackendError {
    constructor(message: string);
}

// @public
export function prepareExecution(backend: IAnalyticalBackend, definition: IExecutionDefinition): IPreparedExecution;


// (No @packageDocumentation comment for this package)

```
