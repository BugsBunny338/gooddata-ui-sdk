// (C) 2020 GoodData Corporation
// tslint:disable
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import * as globalImportUrl from "url";
import * as globalImportQs from "qs";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from "./base";

// utility function that adds support for nested objects in query
const addFlattenedObjectTo = (object: any, baseName: string, target: any): void => {
    const semiFlattened = globalImportQs.parse(globalImportQs.stringify(object), { depth: 0 });
    const flattened = semiFlattened[Object.keys(semiFlattened)[0]] ?? {};

    Object.keys(flattened).forEach((key) => {
        target[`${baseName}${key}`] = (flattened as any)[key];
    });
};

/**
 *
 * @export
 * @interface AFM
 */
export interface AFM {
    /**
     *
     * @type {Array<AttributeItem>}
     * @memberof AFM
     */
    attributes: Array<AttributeItem>;
    /**
     *
     * @type {Array<object>}
     * @memberof AFM
     */
    filters: Array<object>;
    /**
     *
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    measures: Array<MeasureItem>;
}
/**
 *
 * @export
 * @interface AfmExecution
 */
export interface AfmExecution {
    /**
     *
     * @type {AFM}
     * @memberof AfmExecution
     */
    execution: AFM;
    /**
     *
     * @type {string}
     * @memberof AfmExecution
     */
    project: string;
    /**
     *
     * @type {ResultSpec}
     * @memberof AfmExecution
     */
    resultSpec: ResultSpec;
}
/**
 *
 * @export
 * @interface AfmExecutionResponse
 */
export interface AfmExecutionResponse {
    /**
     *
     * @type {ExecutionResponse}
     * @memberof AfmExecutionResponse
     */
    executionResponse: ExecutionResponse;
}
/**
 *
 * @export
 * @interface AfmValidObjectsQuery
 */
export interface AfmValidObjectsQuery {
    /**
     *
     * @type {Array<string>}
     * @memberof AfmValidObjectsQuery
     */
    types: Array<AfmValidObjectsQueryTypesEnum>;
    /**
     *
     * @type {AFM}
     * @memberof AfmValidObjectsQuery
     */
    afm: AFM;
}

/**
 * @export
 * @enum {string}
 */
export enum AfmValidObjectsQueryTypesEnum {
    Facts = "facts",
    Attributes = "attributes",
    Measures = "measures",
    UNRECOGNIZED = "UNRECOGNIZED",
}

/**
 *
 * @export
 * @interface AfmValidObjectsResponse
 */
export interface AfmValidObjectsResponse {
    /**
     *
     * @type {Array<string>}
     * @memberof AfmValidObjectsResponse
     */
    items: Array<string>;
}
/**
 *
 * @export
 * @interface AttributeItem
 */
export interface AttributeItem {
    /**
     *
     * @type {string}
     * @memberof AttributeItem
     */
    localIdentifier: string;
    /**
     *
     * @type {string}
     * @memberof AttributeItem
     */
    displayForm: string;
    /**
     *
     * @type {string}
     * @memberof AttributeItem
     */
    alias?: string;
}
/**
 *
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     *
     * @type {Array<string>}
     * @memberof Dimension
     */
    itemIdentifiers: Array<string>;
}
/**
 * List of returned elements.
 * @export
 * @interface Element
 */
export interface Element {
    /**
     * Title of primary label of attribute owning requested label.
     * @type {string}
     * @memberof Element
     */
    primaryTitle: string;
    /**
     * Title of requested label.
     * @type {string}
     * @memberof Element
     */
    title: string;
}
/**
 *
 * @export
 * @interface ElementsResponse
 */
export interface ElementsResponse {
    /**
     *
     * @type {string}
     * @memberof ElementsResponse
     */
    primaryLabel: string;
    /**
     * List of returned elements.
     * @type {Array<Element>}
     * @memberof ElementsResponse
     */
    elements: Array<Element>;
    /**
     *
     * @type {Paging}
     * @memberof ElementsResponse
     */
    paging: Paging;
    /**
     * Total count of items ignoring all filters (using on ```project``` and  ```label``` from request).
     * @type {number}
     * @memberof ElementsResponse
     */
    totalCountWithoutFilters?: number;
}
/**
 *
 * @export
 * @interface ExecutionLinks
 */
export interface ExecutionLinks {
    /**
     *
     * @type {string}
     * @memberof ExecutionLinks
     */
    executionResult: string;
}
/**
 *
 * @export
 * @interface ExecutionResponse
 */
export interface ExecutionResponse {
    /**
     *
     * @type {Array<ResultDimension>}
     * @memberof ExecutionResponse
     */
    dimensions: Array<ResultDimension>;
    /**
     *
     * @type {ExecutionLinks}
     * @memberof ExecutionResponse
     */
    links: ExecutionLinks;
}
/**
 *
 * @export
 * @interface MeasureItem
 */
export interface MeasureItem {
    /**
     *
     * @type {string}
     * @memberof MeasureItem
     */
    localIdentifier: string;
    /**
     *
     * @type {object}
     * @memberof MeasureItem
     */
    definition: object;
    /**
     *
     * @type {string}
     * @memberof MeasureItem
     */
    alias?: string;
    /**
     *
     * @type {string}
     * @memberof MeasureItem
     */
    format?: string;
}
/**
 * Current page description.
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     * @type {number}
     * @memberof Paging
     */
    total: number;
    /**
     * Count of items in this page.
     * @type {number}
     * @memberof Paging
     */
    count: number;
    /**
     * Offset of this page.
     * @type {number}
     * @memberof Paging
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     * @type {string}
     * @memberof Paging
     */
    next?: string;
}
/**
 *
 * @export
 * @interface ResultDimension
 */
export interface ResultDimension {
    /**
     *
     * @type {Array<object>}
     * @memberof ResultDimension
     */
    headers: Array<object>;
}
/**
 *
 * @export
 * @interface ResultSpec
 */
export interface ResultSpec {
    /**
     *
     * @type {Array<Dimension>}
     * @memberof ResultSpec
     */
    dimensions: Array<Dimension>;
}

/**
 * AfmControllerApi - axios parameter creator
 * @export
 */
export const AfmControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache]
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmRequest(
            params: {
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { afmExecution, skipCache, timestamp } = params;
            // verify required parameter 'afmExecution' is not null or undefined
            if (afmExecution === null || afmExecution === undefined) {
                throw new RequiredError(
                    "afmExecution",
                    "Required parameter afmExecution was null or undefined when calling processAfmRequest.",
                );
            }
            const localVarPath = `/api/afm`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmValidObjectsQuery(
            params: {
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options: any = {},
        ): RequestArgs {
            const { afmValidObjectsQuery } = params;
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            if (afmValidObjectsQuery === null || afmValidObjectsQuery === undefined) {
                throw new RequiredError(
                    "afmValidObjectsQuery",
                    "Required parameter afmValidObjectsQuery was null or undefined when calling processAfmValidObjectsQuery.",
                );
            }
            const localVarPath = `/api/validObjects`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AfmControllerApi - functional programming interface
 * @export
 */
export const AfmControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache]
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmRequest(
            params: {
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse> {
            const localVarAxiosArgs = AfmControllerApiAxiosParamCreator(configuration).processAfmRequest(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmValidObjectsQuery(
            params: {
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse> {
            const localVarAxiosArgs = AfmControllerApiAxiosParamCreator(
                configuration,
            ).processAfmValidObjectsQuery(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * AfmControllerApi - factory interface
 * @export
 */
export const AfmControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         *
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache]
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmRequest(
            params: {
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options?: any,
        ): AxiosPromise<AfmExecutionResponse> {
            return AfmControllerApiFp(configuration).processAfmRequest(params, options)(axios, basePath);
        },
        /**
         *
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmValidObjectsQuery(
            params: {
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options?: any,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return AfmControllerApiFp(configuration).processAfmValidObjectsQuery(params, options)(
                axios,
                basePath,
            );
        },
    };
};

/**
 * AfmControllerApi - interface
 * @export
 * @interface AfmControllerApi
 */
export interface AfmControllerApiInterface {
    /**
     *
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache]
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AfmControllerApiInterface
     */
    processAfmRequest(
        params: {
            afmExecution: AfmExecution;
            skipCache?: boolean;
            timestamp?: string;
        },
        options?: any,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     *
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AfmControllerApiInterface
     */
    processAfmValidObjectsQuery(
        params: {
            afmValidObjectsQuery: AfmValidObjectsQuery;
        },
        options?: any,
    ): AxiosPromise<AfmValidObjectsResponse>;
}

/**
 * AfmControllerApi - object-oriented interface
 * @export
 * @class AfmControllerApi
 * @extends {BaseAPI}
 */
export class AfmControllerApi extends BaseAPI implements AfmControllerApiInterface {
    /**
     *
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache]
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AfmControllerApi
     */
    public processAfmRequest(
        params: {
            afmExecution: AfmExecution;
            skipCache?: boolean;
            timestamp?: string;
        },
        options?: any,
    ) {
        return AfmControllerApiFp(this.configuration).processAfmRequest(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     *
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AfmControllerApi
     */
    public processAfmValidObjectsQuery(
        params: {
            afmValidObjectsQuery: AfmValidObjectsQuery;
        },
        options?: any,
    ) {
        return AfmControllerApiFp(this.configuration).processAfmValidObjectsQuery(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * ElementsControllerApi - axios parameter creator
 * @export
 */
export const ElementsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} workspace Workspace on which to run request.
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processElementsRequest(
            params: {
                workspace: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspace,
                label,
                sortOrder,
                includeTotalWithoutFilters,
                complementFilter,
                patternFilter,
                offset,
                limit,
                skipCache,
            } = params;
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError(
                    "workspace",
                    "Required parameter workspace was null or undefined when calling processElementsRequest.",
                );
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError(
                    "label",
                    "Required parameter label was null or undefined when calling processElementsRequest.",
                );
            }
            const localVarPath = `/api/labelElements`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspace !== undefined) {
                if (typeof workspace === "object") {
                    addFlattenedObjectTo(workspace, "workspace", localVarQueryParameter);
                } else {
                    localVarQueryParameter["workspace"] = workspace;
                }
            }

            if (label !== undefined) {
                if (typeof label === "object") {
                    addFlattenedObjectTo(label, "label", localVarQueryParameter);
                } else {
                    localVarQueryParameter["label"] = label;
                }
            }

            if (sortOrder !== undefined) {
                if (typeof sortOrder === "object") {
                    addFlattenedObjectTo(sortOrder, "sortOrder", localVarQueryParameter);
                } else {
                    localVarQueryParameter["sortOrder"] = sortOrder;
                }
            }

            if (includeTotalWithoutFilters !== undefined) {
                if (typeof includeTotalWithoutFilters === "object") {
                    addFlattenedObjectTo(
                        includeTotalWithoutFilters,
                        "includeTotalWithoutFilters",
                        localVarQueryParameter,
                    );
                } else {
                    localVarQueryParameter["includeTotalWithoutFilters"] = includeTotalWithoutFilters;
                }
            }

            if (complementFilter !== undefined) {
                if (typeof complementFilter === "object") {
                    addFlattenedObjectTo(complementFilter, "complementFilter", localVarQueryParameter);
                } else {
                    localVarQueryParameter["complementFilter"] = complementFilter;
                }
            }

            if (patternFilter !== undefined) {
                if (typeof patternFilter === "object") {
                    addFlattenedObjectTo(patternFilter, "patternFilter", localVarQueryParameter);
                } else {
                    localVarQueryParameter["patternFilter"] = patternFilter;
                }
            }

            if (offset !== undefined) {
                if (typeof offset === "object") {
                    addFlattenedObjectTo(offset, "offset", localVarQueryParameter);
                } else {
                    localVarQueryParameter["offset"] = offset;
                }
            }

            if (limit !== undefined) {
                if (typeof limit === "object") {
                    addFlattenedObjectTo(limit, "limit", localVarQueryParameter);
                } else {
                    localVarQueryParameter["limit"] = limit;
                }
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ElementsControllerApi - functional programming interface
 * @export
 */
export const ElementsControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} workspace Workspace on which to run request.
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processElementsRequest(
            params: {
                workspace: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse> {
            const localVarAxiosArgs = ElementsControllerApiAxiosParamCreator(
                configuration,
            ).processElementsRequest(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ElementsControllerApi - factory interface
 * @export
 */
export const ElementsControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         *
         * @param {string} workspace Workspace on which to run request.
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processElementsRequest(
            params: {
                workspace: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options?: any,
        ): AxiosPromise<ElementsResponse> {
            return ElementsControllerApiFp(configuration).processElementsRequest(params, options)(
                axios,
                basePath,
            );
        },
    };
};

/**
 * ElementsControllerApi - interface
 * @export
 * @interface ElementsControllerApi
 */
export interface ElementsControllerApiInterface {
    /**
     *
     * @param {string} workspace Workspace on which to run request.
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ElementsControllerApiInterface
     */
    processElementsRequest(
        params: {
            workspace: string;
            label: string;
            sortOrder?: "ASC" | "DESC";
            includeTotalWithoutFilters?: boolean;
            complementFilter?: boolean;
            patternFilter?: string;
            offset?: number;
            limit?: number;
            skipCache?: boolean;
        },
        options?: any,
    ): AxiosPromise<ElementsResponse>;
}

/**
 * ElementsControllerApi - object-oriented interface
 * @export
 * @class ElementsControllerApi
 * @extends {BaseAPI}
 */
export class ElementsControllerApi extends BaseAPI implements ElementsControllerApiInterface {
    /**
     *
     * @param {string} workspace Workspace on which to run request.
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ElementsControllerApi
     */
    public processElementsRequest(
        params: {
            workspace: string;
            label: string;
            sortOrder?: "ASC" | "DESC";
            includeTotalWithoutFilters?: boolean;
            complementFilter?: boolean;
            patternFilter?: string;
            offset?: number;
            limit?: number;
            skipCache?: boolean;
        },
        options?: any,
    ) {
        return ElementsControllerApiFp(this.configuration).processElementsRequest(params, options)(
            this.axios,
            this.basePath,
        );
    }
}
